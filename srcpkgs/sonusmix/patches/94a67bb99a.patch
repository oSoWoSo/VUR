From 94a67bb99a4f7ed2a8f32288165f1b42383ea5c5 Mon Sep 17 00:00:00 2001
From: Fl1tzi <git@fl1tzi.com>
Date: Sun, 9 Feb 2025 01:21:39 +0100
Subject: [PATCH] Redesign port mapping and add MONO mapping support

---
 src/pipewire_api/mainloop.rs | 54 ++++++++++++++++++++++++++++++------
 1 file changed, 45 insertions(+), 9 deletions(-)

diff --git a/src/pipewire_api/mainloop.rs b/src/pipewire_api/mainloop.rs
index 90237b4..d09aab6 100644
--- a/src/pipewire_api/mainloop.rs
+++ b/src/pipewire_api/mainloop.rs
@@ -177,25 +177,20 @@ impl Master {
             .filter(|(_, kind, _)| *kind == PortKind::Sink)
             .filter_map(|(port_id, _, _)| store.ports.get(port_id))
             .collect();
-        let port_pairs: Vec<(&Port, &Port)> = start_node
+        let start_ports: Vec<&Port> = start_node
             .ports
             .iter()
             .filter(|(_, kind, _)| *kind == PortKind::Source)
-            .filter_map(|(port_id, _, _)| {
-                let start_port = store.ports.get(port_id)?;
-                let end_port = end_ports
-                    .iter()
-                    .find(|port| port.channel == start_port.channel)?;
-                Some((start_port, *end_port))
-            })
+            .filter_map(|(port_id, _, _)| store.ports.get(port_id))
             .collect();
+        let port_pairs = map_ports(start_ports, end_ports);
         if port_pairs.is_empty() {
             return Err(anyhow!(
                 "No port pairs to connect between nodes {start_id} and {end_id}"
             ));
         }
         for (start_port, end_port) in port_pairs {
-            self.create_port_link(start_port.id, end_port.id)?;
+            self.create_port_link(start_port, end_port)?;
         }
         Ok(())
     }
@@ -293,6 +288,47 @@ impl Master {
     }
 }
 
+/// Maps two different list of ports to a list of mappings.
+/// These are made at best guess but by no means are always correct.
+/// Standard cases such as sorround sound, stereo and MONO ports should
+/// always be correctly mapped.
+///
+/// | Situation | Output |
+/// |-----------|--------|
+/// | start = 1 | map single port to all end ports |
+/// | otherwise | map by channel names |
+// TODO: Maybe announce a possibly incorrect map?
+fn map_ports(start: Vec<&Port>, end: Vec<&Port>) -> Vec<(u32, u32)> {
+    if start.len() == 1 {
+        return end
+            .iter()
+            .map(|end_port| (start[0].id, end_port.id))
+            .collect();
+    }
+    return start
+        .iter()
+        .enumerate()
+        .filter_map(|(index, start_port)| {
+            let start_port_id: u32 = start_port.id;
+            // assume the channel will be at the same index and otherwise search
+            let end_port_id: Option<u32> = end
+                .get(index)
+                .and_then(|port| (port.channel == start_port.channel).then(|| port.id))
+                .or_else(|| {
+                    Some(
+                        end.iter()
+                            .find(|end_port| end_port.channel == start_port.channel)?
+                            .id,
+                    )
+                });
+            if end_port_id.is_none() {
+                debug!("Could not find matching end port for {}", start_port_id);
+            }
+            Some((start_port_id, end_port_id?))
+        })
+        .collect();
+}
+
 pub fn init_node_listeners(
     store: Rc<RefCell<Store>>,
     sender: pipewire::channel::Sender<ToPipewireMessage>,
